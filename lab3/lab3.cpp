/**
 * Практическое занятие №3. Встроенные массивы. Динамическое выделение памяти.
 * Простейшие алгоритмы сортировки и поиска. Сложные указатели.
 */
#include <iostream>
#include <cstring>
#include <ctime>
#include <cstdlib>
using namespace std;

int main()
{
    /**
     * Задание 1. Встроенные массивы.
     */

    /**
     * Задание 1.1.
     *
     * Объявите трехмерный N*M*K массив и сформируйте значения
     * элементов, указанные на иллюстрации ниже, с помощью инициализации при
     * объявлении.
     *
     *                   |--------|
     *                 / |3  3  3 |
     *               |---------|3 |
     *             / | 2  2  2 |3 |
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__|
     *            | 1  1  1 | /
     *            |_________|
     */
    {
        int array[3][3][3] = {
            {{1, 1, 1},
             {1, 1, 1},
             {1, 1, 1}},
            {{2, 2, 2},
             {2, 2, 2},
             {2, 2, 2}},
            {{3, 3, 3},
             {3, 3, 3},
             {3, 3, 3}}};
#ifdef DEBUG_VERSION
        cout << "Task 1.1" << endl;
        for (int (&first_layer)[3][3] : array)
        {
            for (int (&second_layer)[3] : first_layer)
            {
                for (int element : second_layer)
                {
                    cout << element << "  ";
                }
                cout << endl;
            }
            cout << "-------" << endl;
        }
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }
    /**
     * Задание 1.2.
     *
     * Объявите неинициализированный массив и присвойте значения элементам с
     * помощью кода так, чтобы в итоге получился такой же массив, как в задании
     * 1.1.
     */
    {
        int array[3][3][3];
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                for (int k = 0; k < 3; k++)
                {
                    array[i][j][k] = i + 1;
                }
            }
        }
#ifdef DEBUG_VERSION
        cout << "\nTask 1.2" << endl;
        for (int (&first_layer)[3][3] : array)
        {
            for (int (&second_layer)[3] : first_layer)
            {
                for (int element : second_layer)
                {
                    cout << element << "  ";
                }
                cout << endl;
            }
            cout << "-------" << endl;
        }
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }
    /**
     * Задание 1.3.
     *
     * Напишите код, с помощью которого можно найти сумму элементов массива,
     * полученного в задании 1.
     */
    {
        int array[3][3][3] = {
            {{1, 1, 1},
             {2, 2, 2},
             {3, 3, 3}},
            {{1, 1, 1},
             {2, 2, 2},
             {3, 3, 3}},
            {{1, 1, 1},
             {2, 2, 2},
             {3, 3, 3}}};
        int sum = 0;
        for (int (&first_layer)[3][3] : array)
        {
            for (int (&second_layer)[3] : first_layer)
            {
                for (int element : second_layer)
                {
                    sum += element;
                }
            }
        }
#ifdef DEBUG_VERSION
        cout << "Sum in task 1.3: " << sum << endl;
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }
    /**
     * Задание 1.4.
     *
     * Проинициализируйте массив при объявлении следующим образом:
     *
     *                   |--------|
     *                 / |3  0  0 |
     *               |---------|0 |
     *             / | 2  0  0 |0 |
     *            |---------|0 |__|
     *            | 1  0  0 |0 | /
     *            | 0  0  0 |__|
     *            | 0  0  0 | /
     *            |_________|
     *
     * Как это можно сделать наиболее коротким (в смысле количества кода)
     * образом?
     */
    {
        int array[3][3][3] = {
            {{1}},
            {{2}},
            {{3}}};
#ifdef DEBUG_VERSION

        printf("Задание 1.4\n");
        for (int (&first_layer)[3][3] : array)
        {
            for (int (&second_layer)[3] : first_layer)
            {
                for (int element : second_layer)
                {
                    cout << element << "  ";
                }
                cout << endl;
            }
            cout << "-------" << endl;
        }

        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }
    /**
     * Задание 1.5. Инициализация массивов строковыми литералами.
     *
     * Объявите и проинициализируйте строковыми литералами два массива:
     * двухмерный массив и массив указателей. Поясните разницу в использовании
     * элементов таких массивов.
     */

    {
        char two_dim_array[3][10] = {
            "Hello",
            "Vitalya",
            "C++"};
        const char *p_array[] = {
            "Hello",
            "Vitalya",
            "C++"};

        two_dim_array[1][4] = 't';
        // p_array[1][4] = 't'; //невозможно, тк строковые литералы read-only, но можно менять сами указатели
        p_array[1] = "New Vitalya";

#ifdef DEBUG_VERSION
        cout << "Задание 1.5" << endl;
        cout << "Двухмерный массив:" << endl;
        for (int i = 0; i < 3; i++)
        {
            cout << "two_dim_array[" << i << "] = " << two_dim_array[i] << endl;
        }

        cout << "Массив указателей:" << endl;
        for (int i = 0; i < 3; i++)
        {
            cout << "p_array[" << i << "] = " << p_array[i] << endl;
        }

        cout << "Размер памяти:" << endl;

        cout << "Размер two_dim_array: " << sizeof(two_dim_array) << " байт" << endl; // 30 байт (3 по 10)
        cout << "Размер p_array: " << sizeof(p_array) << " байт" << endl;             // 24 байт (3 указателя по 8 байт)
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }

    /**
     * Задание 2. Динамическое выделение памяти.
     */

    /**
     * Задание 2.1.
     *
     * Создайте динамический двухмерный массив с размерностями, вычисляемыми в
     * процессе выполнения программы - N*M, эти размерности можно сформировать
     * случайно в некотором диапазоне или ввести с консоли.
     *
     * Задайте значения элементов помощью генератора случайных чисел.
     *
     * Найдите сумму элементов.
     *
     * Подсказка 1: для генерации случайных чисел используйте функцию
     * стандартной библиотеки - rand() (<cstdlib>).
     *
     * Подсказка 2: На самом деле те значения, которые создаются генератором
     * случайных чисел являются «псевдослучайными», то есть при двух
     * последовательных запусках приложения Вы получаете две одинаковые
     * последовательности значений.
     *
     * Для того чтобы генерируемые "случайные" значения были разными при каждом
     * запуске приложения используйте функции стандартной библиотеки srand()
     * (<cstdlib>) и time() (<ctime>).
     *
     * Функция srand() осуществляет «привязку» начала генерации к указанному в
     * качестве параметра значению.
     *
     * Функция time() задает эту точку отсчета, считывая текущее время.
     */
    {
        cout << "Задание 2.1\n";
        srand(time(0));
        int N, M;
        cout << "Введите количество строк N: ";
        cin >> N;
        cout << "Введите количество столбцов M: ";
        cin >> M;
        if (N <= 0 || M <= 0)
        {
            cout << "Ошибка: размерности должны быть положительными числами!" << endl;
            return 1;
        }
        int **array = new int *[N];
        for (int i = 0; i < N; i++)
        {
            array[i] = new int[M];
        }

        cout << "Сгенерированный массив " << N << "x" << M << ":" << endl;
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < M; j++)
            {
                array[i][j] = rand() % 100;
                cout << array[i][j] << "\t";
            }
            cout << endl;
        }

        {
            int sum = 0;
            for (int i = 0; i < N; i++)
            {
                for (int j = 0; j < M; j++)
                {
                    sum += array[i][j];
                }
            }

            cout << "Сумма всех элементов массива: " << sum << endl;
            cout << endl
                 << "------------------------------------" << endl
                 << endl;
        }

        /**
         * Задание 2.2.
         *
         * В сформированном массиве отсортируйте каждую строку по убыванию
         * значений. Используйте сортировку "выбором".
         */
        for (int row = 0; row < N; row++)
        {
            for (int i = M - 1; i > 0; i--)
            {
                int max = i;
                for (int j = i; j > -1; j--)
                {
                    if (array[row][j] < array[row][max])
                        max = j;
                }
                int tmp = array[row][max];
                array[row][max] = array[row][i];
                array[row][i] = tmp;
            }
        }
#ifdef DEBUG_VERSION

        printf("2.2 Отсортированный массив: \n");
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < M; j++)
            {
                cout << array[i][j] << "\t";
            }
            cout << endl;
        }
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
        /**
         * Задание 2.3.
         *
         * Объявите одномерный массив размерностью N.
         *
         * Сформируйте значение i-ого элемента одномерного массива  равным среднему
         * значению элементов i-ой строки двухмерного массива.
         */
        double *one_dim_array = new double[N];
        for (int i = 0; i < N; i++)
        {
            int row_sum = 0;
            for (int j = 0; j < M; j++)
            {
                row_sum += array[i][j];
            }
            one_dim_array[i] = (double)row_sum / M;
        }
#ifdef DEBUG_VERSION

        printf("2.3 Массив средних: \n");
        for (int i = 0; i < N; i++)
        {
            cout << one_dim_array[i] << endl;
        }

        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
        /**
         * Задание 2.4.
         *
         * Убедитесь, что вся выделенная память очищена.
         *
         * Чтобы убедиться в этом, скомпилируйте программу с включенной проверкой
         * утечек памяти - с ключом `-fsanitize=address`:
         *
         * `gcc <ваши обычные флаги> -fsanitize=address lab3.cpp`
         *
         * Если после выполнении программы выдаются сообщения об утечках, это
         * означает, что где-то не удалена выделенная память.
         */
        for (int i = 0; i < N; i++)
        {
            delete[] array[i];
        }
        delete[] array;
        delete[] one_dim_array;
    }
    /**
     * Задание 3.
     */

    /**
     * Задание 3.1. Онлайн-упорядочивание.
     *
     * Напишите фрагмент кода, который вводит N целых чисел с помощью потока
     * ввода в объявленный Вами встроенный одномерный массив, каждый раз
     * упорядочивая полученное значение по возрастанию.
     *
     * Дайте оценку количества сравнений и перестановок при вводе всех чисел
     * относительно N.
     *
     * Постарайтесь, чтобы и сравнений, и перестановок было не больше, чем
     * k*N^2, где k - некоторое число.
     */
    printf("3.1 Массив средних: \n");
    int N, size = 0;
    cout << "Введите количество целых чисел N: ";
    cin >> N;
    int *array = new int[N];
    cout << "Введите количество целых чисел N: ";
    if (N <= 0)
    {
        cout << "Ошибка: размерность должна быть положительным числом!" << endl;
        return 1;
    }
    for (int i = 0; i < N; i++)
    {
        int num, pos = 0;
        cin >> num;
        for (; pos < size && num > array[pos]; pos++)
            ;

        for (int j = size; j > pos; j--)
        {
            array[j] = array[j - 1];
        }

        array[pos] = num;
        size++;

        cout << "Текущий массив: ";
        for (int k = 0; k < size; k++)
        {
            cout << array[k] << " ";
        }
        cout << endl;
    }

    /**
     * Задание 3.2. Простой поиск.
     *
     * Модифицируйте предыдущее задание следующим образом:очередное значение
     * вводится в массив только при условии, что там еще такого нет (то есть
     * дубли игнорируются).
     */

    /**
     * Задание 4. Сортировка строк.
     *
     * С помощью данной заготовки напишите программу, которая:
     *
     * 1. вводит строки с клавиатуры с помощью cin>>... в объявленный Вами
     *    двухмерный встроенный массив 5*80 элементов типа char; признаком конца
     *    ввода является символ * (то есть строка - "*") или заполнение массива
     *    (больше свободных строк нет);
     * 2. сортирует строки в алфовитном порядке и выводит на экран.
     *
     * Пояснение: крайне не рекомендуется для сортировки сложных объектов
     * физически перемещать их в памяти. Намного эффективнее завести массив
     * указателей на соответствующие строки и перемещать только указатели.
     *
     * Подсказка: для лексиграфического сравнения строк пользуйтесь функцией
     * стандартной библиотеки strcmp(...), заголовочный файл <cstring>.
     */

    {
        /** Определите необходимые значения как константы */

        // STOP_STRING  -  "*"  //признак "прекратить ввод"
        // M  -  80 //максимальный размер одной строки
        // N  -  10 //максимальное количество строк в массиве

        /**
         * Объявите двухмерный массив с именем cBuffer типа char и размерностью
         * N*M.
         */

        /**
         * Объявите массив (с именем cPointers) указателей на строки
         * размерностью N.
         */

        /**
         * Цикл ввода строк:
         * 1. выведите приглашение для ввода;
         * 2. пока не введена строка STOP_STRING или не заполнен весь массив;
         */

        {
            /** ввод строки в массив cBuffer: */

            /** если введена строка - признак окончания, то выйти из цикла */

            /** Присвойте элементу массива cPointers с индексом nIndex */

            /** указатель на строку с номером nIndex в массиве cBuffer */
        }

        /** Выдать диагностику о том, что прием строк завершен.*/

        /**
         * Теперь сортируем строки.
         *
         * Необходимо использовать сортировку строк по методу "всплывающего
         * пузырька" в порядке возрастания.
         *
         * На каждой итерации - промежуточная печать отсортированных строк.
         */
    }

    /*
        /**
         * Задание 5. Динамические строки.
         *
         * Реализуйте задание №4, используя не встроенные, а динамические массивы
         * (массив?). Так как строки могут быть разной длины, эффективным решением
         * было бы отводить под каждую строку ровно столько байтов, сколько
         * требуется для ее хранения.
         *
         * Реализуйте это задание так, чтобы пользователь мог ввести строку любой
         * длины (которая помещается в память компьютера - читайте: неограниченной
         * длины).
         *
         * При этом необходимые параметры (количество строк) сформируйте с помощью
         * потока ввода.
         */

    {
        int nStringNumber;

        /** Цикл ввода строк: */

        /**
         * Цикл сортировки строк по методу "всплывающего пузырька" в порядке
         * возрастания кода первого символа.
         */

        /** Освобождение занятой памяти */
    }

    /**
     * Задание 6. Работа со строками.
     *
     * Реализуйте следующую программу. Пользователь вводит строку (любого
     * размера), после чего пользователю выводится на консоль следующее
     * изображение, где его ввод помещен в "speech bubble":
     *
     *  _____________________________________
     * / Here user input is shown. This line \
     * \ must be at most 40 characters long. /
     *  ------------------------------------
     *     \
     *      \
     *        /\_/\  (
     *       ( ^.^ ) _)
     *         \"/  (
     *       ( | | )
     *      (__d b__)
     *
     *  При этом длина строки в "облачке" должна быть не более 40 символов, при
     *  этом слова должны переноситься аккуратно. Это означет, что не должно
     *  быть переносов в центре слова (если только это слово не больше 40
     *  символов).
     *
     *  Дизайн облачка и ASCII-арт допустимо поменять по усмотрению.
     *
     *  Подсказка: обратите внимание на конкатенацию строковых литералов в
     *  языке С, это позволит задавать подобные рисунки так, чтобы они
     *  адекватно выглядели в коде.
     */

    /**
     * Задание 7. Сложные указатели.
     *
     * Объявление и использование указателей на многомерные массивы.
     * Проинициализируйте трехмерный массив double dArray[4][3][3] так, как
     * показано на рисунке и напишите фрагмент кода, который меняет местами
     * значения элементов четных и нечетных слоев:
     *
     *  было:                |--------|
     *                     / |4  4  4 |
     *                   |--------| 4 |
     *                 / |3  3  3 | 4 |
     *               |---------|3 |   |
     *             / | 2  2  2 |3 | /
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__|
     *            | 1  1  1 | /
     *            |_________|
     *
     *  стало:               |--------|
     *                     / |3  3  3 |
     *                   |--------| 3 |
     *                 / |4  4  4 | 3 |
     *               |---------|4 |   |
     *             / | 1  1  1 |4 | /
     *            |---------|1 |__|
     *            | 2  2  2 |1 | /
     *            | 2  2  2 |__|
     *            | 2  2  2 | /
     *            |_________|
     */

    {

        // for(int i=0; i<...; ...)
        {

            /**
             * Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА
             * РАВЕНСТВА!!!
             */

            // ... =  dArray[i];
            // ... =  dArray[i+1];

            /** переставляем местами элементы i-того и i+1-ого слоев */
        }
    }

    /**
     * Задание 7.
     */

    /**
     * Задание 7.1.
     *
     * Объявите двухмерный встроенный массив элементов типа char.
     *
     * Сформируйте значения элементов массива с помощью генератора случайных
     * чисел таким образом, чтобы в массиве были только символы '*' и '_'.
     *
     * В каждой строке "сдвиньте звездочки" в начало строки, например:
     * было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
     * стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
     * и распечатайте массив по строкам.
     *
     * При этом оцените количество операций, которое требуется для обработки
     * одной строки относительно длины этой строки.
     *
     * Постарайтесь решить эту задачу так, чтобы требовалось не более k*N
     * операций, где N - длина строки, k - некое фиксированное число.
     */

    {
    }

    /**
     * Задание 7.2.
     *
     * Модифицируйте предыдущее задание следующим способом: После заполнения
     * массива с помощью генератора случайных чисел "сдвиньте" звездочки по
     * столбцам вниз и распечатайте результат.
     */

    {
    }

    return 0;
}
