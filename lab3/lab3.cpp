/**
 * Практическое занятие №3. Встроенные массивы. Динамическое выделение памяти.
 * Простейшие алгоритмы сортировки и поиска. Сложные указатели.
 */
#include <iostream>
#include <cstring>
#include <ctime>
#include <cstdlib>
using namespace std;

int main()
{
    /**
     * Задание 1. Встроенные массивы.
     */

    /**
     * Задание 1.1.
     *
     * Объявите трехмерный N*M*K массив и сформируйте значения
     * элементов, указанные на иллюстрации ниже, с помощью инициализации при
     * объявлении.
     *
     *                   |--------|
     *                 / |3  3  3 |
     *               |---------|3 |
     *             / | 2  2  2 |3 |
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__|
     *            | 1  1  1 | /
     *            |_________|
     */
    {
        int array[3][3][3] = {
            {{1, 1, 1},
             {1, 1, 1},
             {1, 1, 1}},
            {{2, 2, 2},
             {2, 2, 2},
             {2, 2, 2}},
            {{3, 3, 3},
             {3, 3, 3},
             {3, 3, 3}}};
#ifdef DEBUG_VERSION
        cout << "Task 1.1" << endl;
        for (int (&first_layer)[3][3] : array)
        {
            for (int (&second_layer)[3] : first_layer)
            {
                for (int element : second_layer)
                {
                    cout << element << "  ";
                }
                cout << endl;
            }
            cout << "-------" << endl;
        }
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }
    /**
     * Задание 1.2.
     *
     * Объявите неинициализированный массив и присвойте значения элементам с
     * помощью кода так, чтобы в итоге получился такой же массив, как в задании
     * 1.1.
     */
    {
        int array[3][3][3];
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                for (int k = 0; k < 3; k++)
                {
                    array[i][j][k] = i + 1;
                }
            }
        }
#ifdef DEBUG_VERSION
        cout << "\nTask 1.2" << endl;
        for (int (&first_layer)[3][3] : array)
        {
            for (int (&second_layer)[3] : first_layer)
            {
                for (int element : second_layer)
                {
                    cout << element << "  ";
                }
                cout << endl;
            }
            cout << "-------" << endl;
        }
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }
    /**
     * Задание 1.3.
     *
     * Напишите код, с помощью которого можно найти сумму элементов массива,
     * полученного в задании 1.
     */
    {
        int array[3][3][3] = {
            {{1, 1, 1},
             {2, 2, 2},
             {3, 3, 3}},
            {{1, 1, 1},
             {2, 2, 2},
             {3, 3, 3}},
            {{1, 1, 1},
             {2, 2, 2},
             {3, 3, 3}}};
        int sum = 0;
        for (int (&first_layer)[3][3] : array)
        {
            for (int (&second_layer)[3] : first_layer)
            {
                for (int element : second_layer)
                {
                    sum += element;
                }
            }
        }
#ifdef DEBUG_VERSION
        cout << "Sum in task 1.3: " << sum << endl;
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }
    /**
     * Задание 1.4.
     *
     * Проинициализируйте массив при объявлении следующим образом:
     *
     *                   |--------|
     *                 / |3  0  0 |
     *               |---------|0 |
     *             / | 2  0  0 |0 |
     *            |---------|0 |__|
     *            | 1  0  0 |0 | /
     *            | 0  0  0 |__|
     *            | 0  0  0 | /
     *            |_________|
     *
     * Как это можно сделать наиболее коротким (в смысле количества кода)
     * образом?
     */
    {
        int array[3][3][3] = {
            {{1}},
            {{2}},
            {{3}}};
#ifdef DEBUG_VERSION

        printf("Задание 1.4\n");
        for (int (&first_layer)[3][3] : array)
        {
            for (int (&second_layer)[3] : first_layer)
            {
                for (int element : second_layer)
                {
                    cout << element << "  ";
                }
                cout << endl;
            }
            cout << "-------" << endl;
        }

        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }
    /**
     * Задание 1.5. Инициализация массивов строковыми литералами.
     *
     * Объявите и проинициализируйте строковыми литералами два массива:
     * двухмерный массив и массив указателей. Поясните разницу в использовании
     * элементов таких массивов.
     */

    {
        char two_dim_array[3][10] = {
            "Hello",
            "Vitalya",
            "C++"};
        const char *p_array[] = {
            "Hello",
            "Vitalya",
            "C++"};

        two_dim_array[1][4] = 't';
        // p_array[1][4] = 't'; //невозможно, тк строковые литералы read-only, но можно менять сами указатели
        p_array[1] = "New Vitalya";

#ifdef DEBUG_VERSION
        cout << "Задание 1.5" << endl;
        cout << "Двухмерный массив:" << endl;
        for (int i = 0; i < 3; i++)
        {
            cout << "two_dim_array[" << i << "] = " << two_dim_array[i] << endl;
        }

        cout << "Массив указателей:" << endl;
        for (int i = 0; i < 3; i++)
        {
            cout << "p_array[" << i << "] = " << p_array[i] << endl;
        }

        cout << "Размер памяти:" << endl;

        cout << "Размер two_dim_array: " << sizeof(two_dim_array) << " байт" << endl; // 30 байт (3 по 10)
        cout << "Размер p_array: " << sizeof(p_array) << " байт" << endl;             // 24 байт (3 указателя по 8 байт)
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
    }

    /**
     * Задание 2. Динамическое выделение памяти.
     */

    /**
     * Задание 2.1.
     *
     * Создайте динамический двухмерный массив с размерностями, вычисляемыми в
     * процессе выполнения программы - N*M, эти размерности можно сформировать
     * случайно в некотором диапазоне или ввести с консоли.
     *
     * Задайте значения элементов помощью генератора случайных чисел.
     *
     * Найдите сумму элементов.
     *
     * Подсказка 1: для генерации случайных чисел используйте функцию
     * стандартной библиотеки - rand() (<cstdlib>).
     *
     * Подсказка 2: На самом деле те значения, которые создаются генератором
     * случайных чисел являются «псевдослучайными», то есть при двух
     * последовательных запусках приложения Вы получаете две одинаковые
     * последовательности значений.
     *
     * Для того чтобы генерируемые "случайные" значения были разными при каждом
     * запуске приложения используйте функции стандартной библиотеки srand()
     * (<cstdlib>) и time() (<ctime>).
     *
     * Функция srand() осуществляет «привязку» начала генерации к указанному в
     * качестве параметра значению.
     *
     * Функция time() задает эту точку отсчета, считывая текущее время.
     */
    {
        cout << "Задание 2.1\n";
        srand(time(0));
        int N, M;
        cout << "Введите количество строк N: ";
        cin >> N;
        cout << "Введите количество столбцов M: ";
        cin >> M;
        if (N <= 0 || M <= 0)
        {
            cout << "Ошибка: размерности должны быть положительными числами!" << endl;
            return 1;
        }
        int **array = new int *[N];
        for (int i = 0; i < N; i++)
        {
            array[i] = new int[M];
        }

        cout << "Сгенерированный массив " << N << "x" << M << ":" << endl;
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < M; j++)
            {
                array[i][j] = rand() % 100;
                cout << array[i][j] << "\t";
            }
            cout << endl;
        }

        {
            int sum = 0;
            for (int i = 0; i < N; i++)
            {
                for (int j = 0; j < M; j++)
                {
                    sum += array[i][j];
                }
            }

            cout << "Сумма всех элементов массива: " << sum << endl;
            cout << endl
                 << "------------------------------------" << endl
                 << endl;
        }

        /**
         * Задание 2.2.
         *
         * В сформированном массиве отсортируйте каждую строку по убыванию
         * значений. Используйте сортировку "выбором".
         */
        for (int row = 0; row < N; row++)
        {
            for (int i = M - 1; i > 0; i--)
            {
                int max = i;
                for (int j = i; j > -1; j--)
                {
                    if (array[row][j] < array[row][max])
                        max = j;
                }
                int tmp = array[row][max];
                array[row][max] = array[row][i];
                array[row][i] = tmp;
            }
        }
#ifdef DEBUG_VERSION

        printf("2.2 Отсортированный массив: \n");
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < M; j++)
            {
                cout << array[i][j] << "\t";
            }
            cout << endl;
        }
        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
        /**
         * Задание 2.3.
         *
         * Объявите одномерный массив размерностью N.
         *
         * Сформируйте значение i-ого элемента одномерного массива  равным среднему
         * значению элементов i-ой строки двухмерного массива.
         */
        double *one_dim_array = new double[N];
        for (int i = 0; i < N; i++)
        {
            int row_sum = 0;
            for (int j = 0; j < M; j++)
            {
                row_sum += array[i][j];
            }
            one_dim_array[i] = (double)row_sum / M;
        }
#ifdef DEBUG_VERSION

        printf("2.3 Массив средних: \n");
        for (int i = 0; i < N; i++)
        {
            cout << one_dim_array[i] << endl;
        }

        cout << endl
             << "------------------------------------" << endl
             << endl;
#endif
        /**
         * Задание 2.4.
         *
         * Убедитесь, что вся выделенная память очищена.
         *
         * Чтобы убедиться в этом, скомпилируйте программу с включенной проверкой
         * утечек памяти - с ключом `-fsanitize=address`:
         *
         * `gcc <ваши обычные флаги> -fsanitize=address lab3.cpp`
         *
         * Если после выполнении программы выдаются сообщения об утечках, это
         * означает, что где-то не удалена выделенная память.
         */
        for (int i = 0; i < N; i++)
        {
            delete[] array[i];
        }
        delete[] array;
        delete[] one_dim_array;
    }
    /**
     * Задание 3.
     */

    /**
     * Задание 3.1. Онлайн-упорядочивание.
     *
     * Напишите фрагмент кода, который вводит N целых чисел с помощью потока
     * ввода в объявленный Вами встроенный одномерный массив, каждый раз
     * упорядочивая полученное значение по возрастанию.
     *
     * Дайте оценку количества сравнений и перестановок при вводе всех чисел
     * относительно N.
     *
     * Постарайтесь, чтобы и сравнений, и перестановок было не больше, чем
     * k*N^2, где k - некоторое число.
     */
    {
        printf("3.1: \n");
        int N, size = 0;
        cout << "Введите количество целых чисел N: ";
        cin.ignore();
        cin >> N;
        int *array = new int[N];
        if (N <= 0)
        {
            cout << "Ошибка: размерность должна быть положительным числом!" << endl;
            delete[] array;
            return 1;
        }
        for (int i = 0; i < N; i++)
        {
            int num, pos = 0;
            cin.ignore();
            cout << "Введите целое число: ";
            cin >> num;
            for (; pos < size && num > array[pos]; pos++)
                ;

            for (int j = size; j > pos; j--)
            {
                array[j] = array[j - 1];
            }

            array[pos] = num;
            size++;

            cout << "Текущий массив: ";
            for (int k = 0; k < size; k++)
            {
                cout << array[k] << " ";
            }
            cout << endl;
        }

        delete[] array;
        // число сравнений ~N^2, сравнений примерно столько же (можно уменьшить, написав бинарный поиск (реазиловал в 3.2 для поиска дублей))

        cout << endl
             << "------------------------------------" << endl
             << endl;
    }

    /**
     * Задание 3.2. Простой поиск.
     *
     * Модифицируйте предыдущее задание следующим образом:очередное значение
     * вводится в массив только при условии, что там еще такого нет (то есть
     * дубли игнорируются).
     */
    {
        printf("3.2: \n");
        int N, size = 0;
        cout << "Введите количество целых чисел N: ";
        cin.ignore();
        cin >> N;
        int *array = new int[N];
        if (N <= 0)
        {
            cout << "Ошибка: размерность должна быть положительным числом!" << endl;
            return 1;
        }
        for (int i = 0; i < N; i++)
        {
            int num, pos = 0;
            bool flag = false;
            do
            {
                flag = false;
                cout << "Введите число: ";
                cin.ignore();
                cin >> num;
                int left = 0, right = size - 1, mid;
                while (left <= right)
                {
                    mid = (left + right) / 2;
                    if (array[mid] == num)
                    {
                        flag = true;
                        cout << "Такое число уже есть!" << endl;
                        cout << "Текущий массив: ";
                        for (int k = 0; k < size; k++)
                        {
                            cout << array[k] << " ";
                        }
                        cout << endl;
                        break;
                        ;
                    }
                    else if (num < array[mid])
                    {
                        right = mid - 1;
                    }
                    else
                    {
                        left = mid + 1;
                    }
                }
            } while (flag);

            for (; pos < size && num > array[pos]; pos++)
                ;

            for (int j = size; j > pos; j--)
            {
                array[j] = array[j - 1];
            }

            array[pos] = num;
            size++;

            cout << "Текущий массив: ";
            for (int k = 0; k < size; k++)
            {
                cout << array[k] << " ";
            }
            cout << endl;
        }
        delete[] array;
        // бинарный поиск log(n) операций

        cout << endl
             << "------------------------------------" << endl
             << endl;
    }
    /**
     * Задание 4. Сортировка строк.
     *
     * С помощью данной заготовки напишите программу, которая:
     *
     * 1. вводит строки с клавиатуры с помощью cin>>... в объявленный Вами
     *    двухмерный встроенный массив 5*80 элементов типа char; признаком конца
     *    ввода является символ * (то есть строка - "*") или заполнение массива
     *    (больше свободных строк нет);
     * 2. сортирует строки в алфовитном порядке и выводит на экран.
     *
     * Пояснение: крайне не рекомендуется для сортировки сложных объектов
     * физически перемещать их в памяти. Намного эффективнее завести массив
     * указателей на соответствующие строки и перемещать только указатели.
     *
     * Подсказка: для лексиграфического сравнения строк пользуйтесь функцией
     * стандартной библиотеки strcmp(...), заголовочный файл <cstring>.
     */

    {
        printf("4: \n");
/** Определите необходимые значения как константы */

// STOP_STRING  -  "*"  //признак "прекратить ввод"
// M  -  80 //максимальный размер одной строки
// N  -  10 //максимальное количество строк в массиве
#define STOP_STRING "*" // признак "прекратить ввод"
#define M 80            // максимальный размер одной строки
#define N 10            // максимальное количество строк в массиве

        /**
         * Объявите двухмерный массив с именем cBuffer типа char и размерностью
         * N*M.
         */

        char cBuffer[N][M];
        /**
         * Объявите массив (с именем cPointers) указателей на строки
         * размерностью N.
         */
        char *cPointers[N];
        /**
         * Цикл ввода строк:
         * 1. выведите приглашение для ввода;
         * 2. пока не введена строка STOP_STRING или не заполнен весь массив;
         */
        int nIndex;
        for (nIndex = 0; nIndex < N; nIndex++)
        {
            /** ввод строки в массив cBuffer: */
            cout << "Строка " << nIndex + 1 << ": ";
            cin.ignore();
            cin >> cBuffer[nIndex];
            /** если введена строка - признак окончания, то выйти из цикла */
            if (strcmp(cBuffer[nIndex], STOP_STRING) == 0)
            {
                break;
            }

            /** Присвойте элементу массива cPointers с индексом nIndex */
            /** указатель на строку с номером nIndex в массиве cBuffer */
            cPointers[nIndex] = cBuffer[nIndex];
        }

        /** Выдать диагностику о том, что прием строк завершен.*/
        cout << "\nПрием строк завершен. Введено строк: " << nIndex << endl;
        /**
         * Теперь сортируем строки.
         *
         * Необходимо использовать сортировку строк по методу "всплывающего
         * пузырька" в порядке возрастания.
         *
         * На каждой итерации - промежуточная печать отсортированных строк.
         */
        for (int i = 0; i < nIndex - 1; i++) //[5, 3, 8, 1, 2]
        {
            cout << "Итерация " << i + 1 << ":\n";

            for (int j = 0; j < nIndex - 1 - i; j++)
            {
                if (strcmp(cPointers[j], cPointers[j + 1]) > 0)
                {
                    char *temp = cPointers[j];
                    cPointers[j] = cPointers[j + 1];
                    cPointers[j + 1] = temp;
                }
            }

            for (int k = 0; k < nIndex; k++)
            {
                cout << cPointers[k] << endl;
            }
            cout << endl;
        }

        cout << endl
             << "------------------------------------" << endl
             << endl;
    }

    /*
        /**
         * Задание 5. Динамические строки.
         *
         * Реализуйте задание №4, используя не встроенные, а динамические массивы
         * (массив?). Так как строки могут быть разной длины, эффективным решением
         * было бы отводить под каждую строку ровно столько байтов, сколько
         * требуется для ее хранения.
         *
         * Реализуйте это задание так, чтобы пользователь мог ввести строку любой
         * длины (которая помещается в память компьютера - читайте: неограниченной
         * длины).
         *
         * При этом необходимые параметры (количество строк) сформируйте с помощью
         * потока ввода.
         */

    {

        printf("5: \n");
        int nStringNumber;
        cout << "Введите количество строчек: ";
        cin >> nStringNumber;
        cin.ignore();
        char **cStringsArr = new char *[nStringNumber]();
#define STOP_STRING "*"
        /** Цикл ввода строк: */
        for (int i = 0; i < nStringNumber; i++)
        {
            int cur_size = 10;
            char *cString = new char[cur_size]();
            cout << "Введите строку:";
            char c = cin.get();
            int cur_pos = 0;
            while (c != '\n')
            {
                if (cur_pos >= cur_size - 1) // не >, тк тогда не вместится \0 и будет переполнение, не получится вписать (*)
                {
                    char *new_cString = new char[cur_size * 2]();
                    for (int i = 0; i < cur_size; i++)
                    {
                        new_cString[i] = cString[i];
                    }
                    delete[] cString;
                    cString = new_cString;
                    cur_size *= 2;
                }
                cString[cur_pos] = c;
                cur_pos++;
                c = cin.get();
            }
            cString[cur_pos] = '\0'; //(*) завершаем строку
            if (strcmp(cString, STOP_STRING) == 0)
            {
                nStringNumber = i;
                delete[] cString;
                break;
            }
            cStringsArr[i] = new char[strlen(cString) + 1];
            strcpy(cStringsArr[i], cString);
            delete[] cString;
        }
        /**
         * Цикл сортировки строк по методу "всплывающего пузырька" в порядке
         * возрастания кода первого символа.
         */
        for (int i = 0; i < nStringNumber - 1; i++)
        {
            for (int j = 0; j < nStringNumber - 1 - i; j++)
            {
                if (strcmp(cStringsArr[j], cStringsArr[j + 1]) > 0)
                {
                    char *temp = cStringsArr[j];
                    cStringsArr[j] = cStringsArr[j + 1];
                    cStringsArr[j + 1] = temp;
                }
            }
        }
#ifdef DEBUG_VERSION
        for (int k = 0; k < nStringNumber; k++)
        {
            cout << cStringsArr[k] << endl;
        }
        cout << endl;
#endif
        /** Освобождение занятой памяти */
        for (int i = 0; i < nStringNumber; i++)
        {
            delete[] cStringsArr[i];
        }
        delete[] cStringsArr;

        cout << endl
             << "------------------------------------" << endl
             << endl;
    }
    /**
     * Задание 6. Работа со строками.
     *
     * Реализуйте следующую программу. Пользователь вводит строку (любого
     * размера), после чего пользователю выводится на консоль следующее
     * изображение, где его ввод помещен в "speech bubble":
     *
     *  _____________________________________
     * / Here user input is shown. This line \
     * \ must be at most 40 characters long. /
     *  ------------------------------------
     *     \
     *      \
     *        /\_/\  (
     *       ( ^.^ ) _)
     *         \"/  (
     *       ( | | )
     *      (__d b__)
     *
     *  При этом длина строки в "облачке" должна быть не более 40 символов, при
     *  этом слова должны переноситься аккуратно. Это означет, что не должно
     *  быть переносов в центре слова (если только это слово не больше 40
     *  символов).
     *
     *  Дизайн облачка и ASCII-арт допустимо поменять по усмотрению.
     *
     *  Подсказка: обратите внимание на конкатенацию строковых литералов в
     *  языке С, это позволит задавать подобные рисунки так, чтобы они
     *  адекватно выглядели в коде.
     */

    /**
     * Задание 7. Сложные указатели.
     *
     * Объявление и использование указателей на многомерные массивы.
     * Проинициализируйте трехмерный массив double dArray[4][3][3] так, как
     * показано на рисунке и напишите фрагмент кода, который меняет местами
     * значения элементов четных и нечетных слоев:
     *
     *  было:                |--------|
     *                     / |4  4  4 |
     *                   |--------| 4 |
     *                 / |3  3  3 | 4 |
     *               |---------|3 |   |
     *             / | 2  2  2 |3 | /
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__|
     *            | 1  1  1 | /
     *            |_________|
     *
     *  стало:               |--------|
     *                     / |3  3  3 |
     *                   |--------| 3 |
     *                 / |4  4  4 | 3 |
     *               |---------|4 |   |
     *             / | 1  1  1 |4 | /
     *            |---------|1 |__|
     *            | 2  2  2 |1 | /
     *            | 2  2  2 |__|
     *            | 2  2  2 | /
     *            |_________|
     */

    {

        // for(int i=0; i<...; ...)
        {

            /**
             * Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА
             * РАВЕНСТВА!!!
             */

            // ... =  dArray[i];
            // ... =  dArray[i+1];

            /** переставляем местами элементы i-того и i+1-ого слоев */
        }
    }

    /**
     * Задание 7.
     */

    /**
     * Задание 7.1.
     *
     * Объявите двухмерный встроенный массив элементов типа char.
     *
     * Сформируйте значения элементов массива с помощью генератора случайных
     * чисел таким образом, чтобы в массиве были только символы '*' и '_'.
     *
     * В каждой строке "сдвиньте звездочки" в начало строки, например:
     * было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
     * стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
     * и распечатайте массив по строкам.
     *
     * При этом оцените количество операций, которое требуется для обработки
     * одной строки относительно длины этой строки.
     *
     * Постарайтесь решить эту задачу так, чтобы требовалось не более k*N
     * операций, где N - длина строки, k - некое фиксированное число.
     */

    {
    }

    /**
     * Задание 7.2.
     *
     * Модифицируйте предыдущее задание следующим способом: После заполнения
     * массива с помощью генератора случайных чисел "сдвиньте" звездочки по
     * столбцам вниз и распечатайте результат.
     */

    {
    }

    return 0;
}
