/**
 * Практическое занятие №4. Функции. Объявление, определение, вызов. Передача
 * параметров. Возвращение значения.
 */
#include <iostream>
// #include <cstdio>
#include <cstdarg>

#include "other.h"
using namespace std;
int main()
{
    /**
     * Задание 1. Ссылки.
     *
     * Объявите ссылку на тип double. Посредством ссылки измените значение.
     */
    {
        double value = 3.14;
        double &ref = value;
        ref = 3.24;
    }

    /**
     * Раскомментируйте следующую строку.
     *
     * Объясните, почему возникает ошибка? Что следует сделать, чтобы
     * компилятор не выдавал ошибки?
     */
    {
        // int &ref = 1;
        // нельзя инициализировать неконстантную ссылку rvalue
        const int &ref = 1;
        // или
        int x = 1;
        int &iRef = x;
    }

    /**
     * Ниже задан указатель `pc`, задайте ссылку на этот указатель.
     *
     * Посредством ссылки измените:
     * 1. значение по адресу;
     * 2. сам адрес.
     */

    {
        char c = 'A';
        char cOther = 'V';
        char *pc = &c;
        char *&pc_ref = pc;

        *pc_ref = 'X'; // pc_ref -> c = 'X'

        pc_ref = &cOther; // pc_ref -> cOther = 'V'
    }

    /**
     * Задание 2. Передача параметров в функцию.
     */

    /**
     * Задание 2.1.
     *
     * Объявите и определите три функции, которые увеличивают заданное с
     * помощью параметра значение на 1:
     *
     * 1. функция inc_by_value() - в нее аргумент передается по значению;
     * 2. функция inc_by_pointer() - в нее аргумент передается по указателю;
     * 3. функция inc_by_reference() - в нее аргумент передается по ссылке.
     *
     * Поместите объявления этих функций в заголовочный файл `other.h`, а их
     * определение в `other.cpp`.
     */

    // Замечание: объявления функций принято помещать в заголовочный файл
    {
        /**
         * Значение этой переменной должно быть увеличено с помощью каждой из
         * функций на единицу.
         */
        int val = 1;
        val = inc_by_value(val);
        cout << "После inc_by_value(): val = " << val << endl;

        inc_by_pointer(&val);
        cout << "После inc_by_pointer(): val = " << val << endl;

        inc_by_reference(val);
        cout << "После inc_by_reference(): val = " << val << endl;

        cout << "----------" << endl;
    }

    /**
     * Задание 2.2. Передача параметров c помощью указателя и по ссылке.
     * Перегруженные имена функций.
     *
     * Создайте функцию (функции) swap(), которая меняет значения переменных nX
     * и nY местами:
     *
     * 1. Функция должна принимать два указателя на int, оперируя с которыми
     *    менять значения переменных в вызывающей программе.
     * 2. Функция должна принимать две ссылки на int.
     *
     * Проверьте правильность с помощью приведенного ниже фрагмента.
     */

    {
        int nX = 1;
        int nY = -1;
        /** поменяли местами значения nX и nY с помощью указателей на nX и nY */
        swap(&nX, &nY);
        cout << "После swap через указатели: nX = " << nX << ", nY = " << nY << endl;

        /** а теперь обратно с помощью ссылок на nX и nY */
        swap(nX, nY);
        cout << "После swap через ссылки: nX = " << nX << ", nY = " << nY << endl;

        cout << "----------" << endl;
    }

    /**
     * Задание 3. Указатели на массивы в качестве аргументов.
     */

    /**
     * Задание 3.1. Поиск минимума в массиве.
     *
     * Напишите следующие функции для поиска минимума в целочисленном массиве:
     *
     * 1. Для поиска в одномерном массиве.
     * 2. Для поиска в двумерном динамическом массиве (массиве указателей).
     *
     * Что надо передать в такую функцию кроме самого массива?
     *
     * Постарайтесь использовать во второй функции первую, чтобы не повторять
     * логику.
     */
    {
        /** Задайте массивы для проверки и проверьте результат работы функции */

        const int arr1D[] = {5, 2, 8, -1, 7, 3};
        const int size1D = sizeof(arr1D) / sizeof(arr1D[0]);
        cout << "Минимум в одномерном массиве ";
        print_array(arr1D, size1D);
        cout << ": " << find_Min_1D(arr1D, size1D) << endl;

        const int rows = 4;
        const int cols = 5;
        int **arr2D = new int *[rows];
        for (int i = 0; i < rows; i++)
        {
            arr2D[i] = new int[cols];
            for (int j = 0; j < cols; j++)
            {
                arr2D[i][j] = i * cols + j + 1;
            }
        }
        arr2D[1][2] = -10;
        cout << "Минимум в двумерном массиве ";
        print_2D_array(const_cast<const int **>(arr2D), rows, cols);
        cout << ": " << find_Min_2D(const_cast<const int **>(arr2D), rows, cols) << endl;
        /**
         * Покажите, как можно использовать эту функцию для встроенных
         * двумерных массивов.
         */
        const int staticArr[rows][cols] = {
            {1, 2, 3, 4, 5},
            {6, 7, -10, 9, 10},
            {11, 12, 13, 14, 15},
            {16, 17, 18, 19, 20}};
        cout << "Минимум во встроенном массиве ";
        print_array(reinterpret_cast<const int *>(staticArr), rows * cols);
        cout << ": " << find_Min_1D(reinterpret_cast<const int *>(staticArr), rows * cols) << endl;
        for (int i = 0; i < rows; i++)
        {
            delete[] arr2D[i];
        }
        delete[] arr2D;

        cout << "----------" << endl;
    }

    /**
     * Задание 3.2. Сравнение строк.
     *
     * Напишите функцию сравнения двух строк - my_str_cmp().
     *
     * Функция должна принимать два указателя на сравниваемые строки.
     *
     * Функция должна возвращать отрицательное значение, если первая строка
     * лексиграфически меньше второй, 0 - если они равны и положительное
     * значение, если первая строка больше второй.
     *
     * Вспомните, что признаком конца строки является нулевой байт.
     */

    {
        /** Создайте две строки для сравнения */
        const char *str1 = "vitalya";
        const char *str2 = "vitalik";
        /** Вызовите функцию сравнения */
        const int out = my_Str_Cmp(str1, str2);
        /** Выведите результат сравнения с помощью cout */
        cout << str1 << " vs " << str2 << ": " << out << endl;

        cout << "----------" << endl;
    }

    /**
     * Задание 3.3. Типизация параметров и проверка предварительных условий.
     */

    /**
     * Задание 3.3.1.
     *
     * При передаче данных по ссылке или по указателю хорошим тоном является
     * указывать, собирается ли функция менять данные по этим адресам или нет,
     * с помощью константности указателя (вспоминаем лабораторную №2).
     *
     * Задайте в заданиях 3.1 и 3.2 те указатели, которые используются только
     * на чтение, константными.
     */

    /**
     * Задание 3.3.2.
     *
     * К сожалению, система типов языка С (как впрочем и других языков)
     * недостаточно выразительна, чтобы с помощью типов передаваемых параметров
     * выразить ожидания функции по поводу входных данных. Поэтому внутри
     * функций бывает необходимо устанавливать дополнительные проверки.
     *
     * Например, в функциях из задания 3.1 вы, вероятно, передавали в качестве
     * аргумента размер массива и, так же вероятно, что результат выполнения
     * функции не будет иметь смысла, если этот размер меньше 1.
     *
     * Для служебных функций - то есть таких функций, которые используются вами
     * же и вашими коллегами - хорошим тоном является с помощью макроса
     * `assert` из заголовочного файла `cassert`. Для других функций необходимо
     * сигнализовать об ошибке более вдумчиво.
     *
     * Добавьте проверку положительности размера в функции из задания 3.1 и
     * посмотрите, что будет, если в функцию передать некорректное значение.
     *
     * Соберите вашу программу для релиза (с директивой NDEBUG) и выполните код
     * с некорректными значениям. Объясните полученные результаты.
     */
    const int arr1D[] = {5, 2, 8, -1, 7, 3};
    const int size1D = -1;
    cout << "СЛОМАННЫЙ КОД";
    print_array(arr1D, size1D);
    cout << ": " << find_Min_1D(arr1D, size1D) << endl;

    cout << "----------" << endl;
    // NDEBUG отключает отладлочные макросы и функции, поэтому assert не работает.
    //  СЛОМАННЫЙ КОД{: 5
    //  если его не ставить, будет
    //  lab4.exe: other.cpp:37: int findMin1D(const int*, int): Assertion `arr != nullptr && size > 0' failed.
    //  Aborted (core dumped)

    /**
     * Задание 4. Ссылки в качестве параметров. Передача указателя на
     * встроенный массив в качестве параметра функции.
     *
     * Напишите две взаимодополняющие друг друга функции:
     *
     * 1.  ... day_of_year(...) - преобразует день месяца (число,месяц и год
     *    задаются в качестве параметров) в порядковый день года (возвращаемое
     *    значение);
     * 2. ... day_of_month(...) - функция преобразует порядковый день года в день
     *    месяца (принимает год и порядковый день года в качестве параметров и
     *    должна сформировать день месяца и номер месяца и каким-то образом
     *    сообщить эти значения вызывающей процедуре).
     *
     * Проверьте работоспособность обеих функций с помощью следующего
     * фрагмента.
     */

    {
        /**
         * В процессе вычислений Вам придется учитывать "високосный -
         * невисокосный" год.
         *
         * Для этого предлагается в каждую функцию в качестве одного из
         * параметров передавать данные приведенного ниже двухмерного массива
         * nDayTab.
         */
        int nDayTab[2][12] = {
            {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},  // невисокосный год
            {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}}; // високосный год

        /** Вызов функции DayOfYear */
        const int day = 24, month = 3, year = 2007;
        int dayOfYear = day_of_year(day, month, year, nDayTab);
        cout << "day_of_year: " << dayOfYear << endl;
        /** Проверка результата обратной функцией DayOfMonth */

        int dayOfMonth_day, dayOfMonth_month;
        day_of_month(dayOfYear, year, dayOfMonth_day, dayOfMonth_month, nDayTab);

        cout << "day_of_month: " << dayOfMonth_month << "." << dayOfMonth_day << endl;
        
        cout << "----------" << endl;
    }

    /**
     * Задание 5.
     *
     * Создайте одномерный динамический массив, заполните его значениями.
     *
     * Напишите функцию add_unique, которая добавляет в массив новое значение
     * только при условии, что такого значения в массиве еще нет.
     *
     * Для проверки напишите функцию print_array, которая выводит значения всех
     * элементов на экран.
     *
     * Ваша функция должна работать в следующем фрагменте кода.
     */

    {
        srand(time(0));
        int n = 10;            // сформируйте значение n
        int *arr = new int[n]; // создайте тут массив размера n

        /** заполнение случайными значениями */
        for (int i = 0; i < n; ++i)
        {
            arr[i] = rand() % 10;
        }

        print_array(arr, n);
        cout << endl;
        for (int i = 0; i < 100; ++i)
        {
            int new_value;
            new_value = rand() % 10; // случайное значение
            new_value = new_value % 10;
            /** вызов функции добавления в массив */
            arr = add_unique(arr, n, new_value);
        }

        /** печать массива на экран */
        print_array(arr, n);
        cout << endl;

        /**
         * Тут должно быть не более 10 + n элементов, так как во втором цикле
         * могут быть получены только 10 разных вариантов.
         */

        delete[] arr;
        
        cout << "----------" << endl;
    }

    /**
     * Задание 6. Рекурсивные функции.
     *
     * Напишите рекурсивную функцию вычисления суммы первых N натуральных
     * чисел.
     */

    {
        int N = 4;
        cout << "сумма первых " << N << " натуральных чисел: " << sum_of_natural_numbers(N) << endl;
        
        cout << "----------" << endl;
    }

    /**
     * Задание 7. Кодирование-декодирование информации. Обработка ошибок.
     *
     * Напишите набор функций, которые будут осуществлять кодировку-декодировку
     * информации из "сырых" байтов в ограниченный набор из 32 печатаемых
     * символов из таблицы {A, B, C, ..., Z, 1, 2, 3, 4, 5, 6}. Делается это
     * следующим образом: данная последовательность байтов разделяется на части
     * по 5 бит (если делится неровно - заполняем нулями). Каждая пятерка битов
     * переводится в целое число от 0 до 31 и по этому индексу выбирается
     * символ в таблице.
     *
     * Например, два байта 0x1E47 = 30, 71 будут закодированы так:
     *
     * 1. запишем в двоичном виде и разделим на пятерки (дополнив нулями):
     *    0001 1110 0100 0111 -> 00011 11001 00011 10000
     * 2. каждую пятерку переведем в число:
     *    00011 11001 00011 10000 -> 3 25 3 16
     *    00000011 00011001 00000011 00010000
     * 3. Для каждого числа подставим символ из таблицы:
     *    3 25 3 16 -> DZDQ
     *
     * Таким образом из двух байт, которые могут принимать любые значения, мы
     * получили 4 символа из английского алфавита (и нескольких цифр), которые
     * можно, например, напечатать на экран.
     *
     * Напишите семейство функций, которые бы реализовали такое преобразование:
     *
     * 1. int encoded32_size(int raw_size) - функция, которая вычисляет размер
     *    закодированных данных при размере оригинальных данных `raw_size`.
     *
     * 2. int decoded32_size(int encode_size) - функция, обратная первой.
     *
     * 3. int encode32(const char *raw_data, int raw_size, char *dst) -
     *    функция кодирует "сырые" байты `raw_data` размером `raw_size` и
     *    записывает результат в буфер `dst`; предполагается, что по адресу
     *    `dst` уже выделена память; функция возвращает 0 при удачном
     *    выполнении и возвращает 1, если какой-то из переданных аргументов
     *    имеет недопустимое значение.
     *
     * 4. int decode32(const char *encoded_data, int encoded_size, char *dst) -
     *    функция, обратная третьей; возвращает 0 при успешном декодировании,
     *    1 при недопустимом значении аргументов; 2 при недопустимом символе в
     *    `encoded_data` (не из таблицы).
     *
     * Проверьте правильность работы функций: закодируйте строки разной длины,
     * после чего декодируйте их. Декодированные строки должны совпадать с
     * изначальными.
     */
    {
        char raw_data[] = {0x1e, 0x47};
        int raw_data_size = sizeof(raw_data) / sizeof(raw_data[0]);
        int enc32_size = encoded32_size(raw_data_size);
        int dec32_size = decoded32_size(enc32_size);
        char *dst = new char[enc32_size]();
        char *dec_dst = new char[dec32_size]();

        cout << "enc32_size: " << enc32_size << endl;
        cout << "dec32_size: " << dec32_size << endl;
        encode32(raw_data, raw_data_size, dst);

        cout << "Закодировано: ";
        for (int i = 0; i < enc32_size; i++)
        {
            cout << dst[i];
        }
        cout << endl;

        decode32(dst, enc32_size, dec_dst);
        cout << "Декодировано: ";
        for (int i = 0; i < raw_data_size; i++)
        {
            cout << std::hex << int(dec_dst[i]) << " " << std::dec;
        }
        cout << endl;
        delete[] dec_dst;
        delete[] dst;
        
        cout << "----------" << endl;
    }
    /**
     * Задание 8. Функции и макросы с переменным числом параметров.
     */

    /**
     * Задание 8.1.
     *
     * Напишите функцию var_args, которая принимает переменное число аргументов
     * типа int и выводит на печать число принятых параметров и их значения.
     *
     * Функция должна работать с помощью макросов va_start, va_arg и va_end.
     *
     * Признаком конца списка является нулевое значение.
     */
    {

        int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
        cout << "var_args(nN1, 0): ";
        var_args(nN1, 0);
        cout << "var_args(nN1, nN2, 0): ";
        var_args(nN1, nN2, 0);
        cout << "var_args(nN1, nN2, nN3, nN4, nN5, 0): ";
        var_args(nN1, nN2, nN3, nN4, nN5, 0);
        
        cout << "----------" << endl;
    }

    /**
     * Задание 8.1.
     *
     * Задайте макрос VAR_ARGS с переменным числом параметров, который будет
     * вызывать функцию var_args с параметрами макроса, но подставлять в конец
     * 0. Таким образом эту функцию можно будет вызывать без нуля в конце.
     */

    {
#define VAR_ARGS(...) (var_args(__VA_ARGS__, 0))
        cout << "VAR_ARGS(nN1): ";
        int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
        VAR_ARGS(nN1);
        cout << "VAR_ARGS(nN1, nN2): ";
        VAR_ARGS(nN1, nN2);
        cout << "VAR_ARGS(nN1, nN2, nN3, nN4, nN5): ";
        VAR_ARGS(nN1, nN2, nN3, nN4, nN5);
        
        cout << "----------" << endl;
    }

    /**
     * Задание 9. Возвращение адреса.
     *
     * Напишите функцию, которая находит минимальное значение в массиве, таким
     * образом, чтобы ее вызов можно было использовать слева от знака
     * равенства:
     *
     * `*my_min(параметры) = 0;`
     */
    {
        int arr1D[] = {5, 2, 8, -1, 7, 3};
        const int size = sizeof(arr1D) / sizeof(arr1D[0]);
        *my_min(arr1D, size) = 1234567;
        print_array(arr1D, size);
        cout << endl;
    }

    return 0;
}
