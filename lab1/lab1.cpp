/**
 * Практическое занятие №1. Базовые типы данных, операторы языка, простой
 * ввод-вывод.
 *
 * В результате выполнения данной работы слушатель получает много мелких, но
 * необходимых для дальнейшей работы навыков, поэтому задание построено как
 * последовательность закомментированных блоков, которые требуется
 * последовательно раскомментировать, отвечая при этом на поставленные вопросы.
 *
 * Необходимое программное обеспечение:
 *
 * - Unix-совместимая командная строка (для Windows необходимо установить WSL);
 * - компилятор g++, отладчик gdb (для установки в командной строке: 
 *   `apt update; apt install gcc g++ gdb`)
 * - любимый текстовый редактор.
 *
 * Примерная последовательность действий при отладке проекта:
 * 1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст
 *    программы;
 * 2. скомпилируйте программу (в командной строке: `g++ -g lab1.cpp`);
 * 3. запустите отладчик (в командной строке `gdb ./a.out`);
 * 4. в отладчике установите точку останова на нужной строке (например, 
 *    `break 55` для 55 строки или `b 55` - так короче) и начните выполнение 
 *    программы (`run` или `r`).
 * 5. выведите значение интересующей переменной (`print cByte` или `p cByte`)
 *    или добавьте переменную для постоянного отслеживания (`watch cByte`).
 * 6. Переходите к следующей точке останова (`c`) или к следующей строке (`n`).
 */

#include  <iostream>

int nTwin = 1;
namespace TwinSpace { int nTwin = 2; }

int main()
{

/**
 * Задание 1. Работа с отладчиком. Базовые типы данных. Литералы.
 *
 * Выполняя программу по шагам, следите за значениями переменных и
 * интерпретируйте результат (помните, что количество байт, отводимых под
 * int, системо-зависимо).
 *
 * Обратите внимание на разную интерпретацию отладчиком signed и unsigned
 * целых типов данных, а также на внутреннее представление отрицательных
 * целых чисел.
 */

char cByte = 'A'; //65 'A'
cByte = 0x42; //66 'B'
cByte = 66; //66 'B'
cByte = -1; //-1 '\377'

unsigned char ucByte = 0x41; //65 'A'
ucByte = 'B'; //66 'B'
ucByte = -1; //255 '\377' - 8ричное 255

int iInt = 0xffffffff; //-1

unsigned int uiInt = 0xffffffff; //4294967295

float fFloat = 1.0;  //1
double dDouble = 1.; //1

/**
 * Выполните фрагмент, приведенный далее. В комментариях отразите, что
 * реально заносится в переменную. Объясните разницу между этим значением и
 * инициализатором.
 */

double d = 0.1234567890123456789123456789; //0.12345678901234568 
float  f = 0.1234567890123456789123456789; //0.123456791

d = 1.; //1
d = 0.999999999999999999999999999999999; //1

/**
 * В комментариях напишите результат, возвращаемый оператором sizeof для
 * переменной типа wchar_t (ее размер)
 */

wchar_t cw = L'Ф'; //1060 L'Ф'
size_t n = sizeof(cw); //2 на винде, 4 через wls(шок)


/**
 * Задание 2a. Неявное приведение типов данных. 
 *
 * Объясните разницу результата при выполнении (1) и (2): Покажите явно
 * (напишите в коде) преобразования, которые неявно выполняет компилятор
 */

iInt = 1;
double dDouble1 = (int) iInt / 3;     // (1) 0
double dDouble2 = (double) iInt / 3.;    // (2) 0.33333333333333331

/**
 * Ассоциативность операторов.
 *
 * Синтаксис языка C допускает "цепочечное" присваивание (как в строках (1)
 * и (2)). Посмотрев результаты выполнения строк (1) и (2) (значения
 * переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок
 * выполнения присваиваний при цепочечной записи и объясните результат.
 *
 * Расставьте скобки, явно определяющие порядок выполнения, как это сделал
 * бы компилятор. Объясните (в комментариях) предупреждения (warnings)
 * компилятора.
 */

short sShort;
dDouble = fFloat = iInt = sShort = cByte = 3.3 / 3; // (1) справа налево, cByte1 = 1,тк целое, все остальные по цепочке

cByte = sShort = iInt = fFloat = dDouble = 3.3 / 3; // (2) dDouble = 1.0999999999999999, fFloat = 1.10000002, далее приводятся типы, 1.10000002 округляется до 1

/**
 * Ниже Вам дан пример "небрежного" использования неявного приведения
 * типов, что может привести к нежелательным результатам - объясните (в
 * комментариях), к каким?
 *
 * Напишите явно преобразования, которые неявно выполняет компилятор.
 */

iInt = 257;
cByte = (char) iInt; // останется 1, тк 257 = 100000001, останется 1 = 00000001, тк char хранит только 1 байт, а 9 бит обрежется

unsigned char cN1 = 255, cN2 = 2, cSum;
cSum = (unsigned char) cN1 + (unsigned char) cN2; // получилось (cN1 + cN2) = 257 = 100000001 -> 1 обрежется, останется 00000001 = 1

/**
 * Сравните предыдущую строчку с приведенной ниже. 
 *
 * Объясните (в комментариях), почему в следующей строке не происходит
 * выход за разрядную сетку
 *
 * Напишите явно преобразования, которые неявно выполняет компилятор
 */

int iSum = (int) cN1 + (int) cN2; //int хранит до 4 байтов, здесь же нужно всего 2(хотя используется 4)

/**
 * Напишите, почему при сложении одинаковых значений (одинаковых в двоичной
 * системе) в строках (1) и (2) получаются разные результаты.
 *
 * Напишите явно преобразования, которые неявно выполняет компилятор и
 * объясните, что при этом происходит.
 */

char c1 = 0xff, c2 = 2; // c1 = -1 (тк с1 signed), c2 = 2
unsigned char uc1 = 0xff, uc2 = 2; // uc1 = 255, uc2 = 2
int iSum1 = (int) c1 + (int) c2;   //(1) -1 + 2 = 1
int iSum2 = (int) uc1 + (int) uc2; //(2) 255 + 2 = 257


/**
 * Задание 2b. Явное приведение типов данных.
 *
 * Проинтерпретируйте результат (значения переменной dDouble) в строке (3).
 *
 * Напишите явно преобразования, которые неявно выполняет компилятор.
 */

int nTmp = 100, nn = 3;
dDouble = 3.3 + (int)(nTmp / nn); // (3) dDouble = 36.299999999999997 (не 36.3 из-за специфики хранения вещественных чисел)

/**
 * Получите результат без потери точности с помощью оператора явного
 * приведения типа.
 */

// double dDouble3 = ...     // (4)

double dDouble3 = 3.3 + (double) nTmp / (double) nn; // можно привести только один из nTmp и nn



/**
 * Задание 3. Область действия, область видимости и время существования
 * переменных.
 *
 * В этом фрагменте фигурируют четыре переменных с одним и тем же именем
 * nTwin - одна глобальная, вторая определена в своем пространстве имен,
 * (определены выше в начале модуля) третья - локальная внутри функции
 * main(), четвертая - вложенная локальная внутри блока. 
 *
 * В данном задании требуется в выделенных местах фрагмента определить, к
 * какой из четырех переменных идет обращение, а также факт существования и
 * видимости для всех четырех, заполнив приведенные в задании таблицы.
 *
 * Для выведения информации в отладчике можно воспользоваться командой 
 * `info locals`, которая выведет локальные переменные в функции main(),
 * и командой `watch nTwin` или `wacth ::nTwin` для отслеживания значений
 * переменных.
 */

nTwin = 100; //глобальная (перед мейн), 1 -> 100
TwinSpace::nTwin = 300; //из пространства имён twinspace. 2 -> 300
nTwin++; //глобальная (перед мейн), 100 -> 101

int nTwin; //объявление локальной nTwin 
nTwin = 200; //локальная стала 200
::nTwin++; //глобальная 101 -> 102

{
int nTwin; //вложенная локальная внутри блока
nTwin = -1; //вложенная локальная внутри блокf = -1
::nTwin++; //глобальная 102 -> 103
TwinSpace::nTwin++;//из пространства имён twinspace. 300 -> 301
}

nTwin--; //локальная 200 -> 199


/**
 * Задание 4. Спецификатор класса памяти - static.
 *
 * 1. Для каждой итерации цикла напишите значения пременных nLocal# и
 *    nStatic#.
 * 2. Напишите, когда выполняется инициализация обеих переменных.
 * 3. Поясните (в комментарии) разницу между способом инициализации
 *    переменных nStatic1 и nStatic2 и поясните побочный эффект, влияющий 
 *    на переменную nLocal2.
 */

for (int i = 0; i < 3; i++)
{
static int nStatic1 = 100;
int nLocal1 = 100;
int nLocal2 = 200;
static int nStatic2 = nLocal2++ * 2;
nStatic1 = 100;
nStatic1++;
nStatic2++;
nLocal1++;
}
/**
 * i = 0: инициализируется nStatic1 = 100, nStatic2 = 400, nLocal1 = 100, nLocal2 = 200
 * после выполнения: nStatic1 = 101 (останется), nStatic2 = 401 (останется), nLocal1 = 101 (сбросится), nLocal2 = 201 (сбросится) 
 * 
 * 
 * i = 1: инициализируется nLocal1 = 100, nLocal2 = 200
 * сохраняются прошлые значения static переменных: nStatic1 = 101, nStatic2 = 401
 * после выполнения: nStatic1 = 102 (останется), nStatic2 = 402 (останется), nLocal1 = 101 (сбросится), nLocal2 = 200 (сбросится) 
 * 
 * 
 * i = 2: инициализируется nLocal1 = 100, nLocal2 = 200
 * сохраняются прошлые значения static переменных: nStatic1 = 102, nStatic2 = 402
 * после выполнения: nStatic1 = 103 (сбросится, тк цикл кончится), nStatic2 = 404 (сбросится, тк цикл кончится), nLocal1 = 101 (сбросится), nLocal2 = 200 (сбросится) 
 * 
 * nStatic1 и nStatic2 инициализируются один раз. 
 * nStatic1 = 100 - константный, а nStatic2 = nLocal2++ * 2 - выражение с побочным эффектом, которое только в первую итерацию цикла i = 0 прибавляет к nLocal2 единицу
 */

/**
 * Напишите:
 * 1. как изменилось поведение пременной nStatic1?
 * 2. как эта переменная _инициализирована_?
 */

for (int i = 0; i < 3; i++)
{
static int nStatic1;
nStatic1 = 100;
int nLocal1 = 100;
nStatic1++;
nLocal1++;
}

/**
 * i = 0: инициализируется nStatic1 = 0 (на следующей строке изменяется на 100), nLocal1 = 100
 * после выполнения: nStatic1 = 101 (останется), nLocal1 = 101 (сбросится)
 * 
 * i = 1: инициализируется nLocal1 = 100
 * сохраняются прошлые значения static переменных: nStatic1 = 101, присваевается 100 (nStatic1 = 100) 
 * после выполнения: nStatic1 = 101 (останется), nLocal1 = 101 (сбросится)
 * 
 * i = 2: инициализируется nLocal1 = 100
 * сохраняются прошлые значения static переменных: nStatic1 = 101, присваевается 100 (nStatic1 = 100) 
 * после выполнения: nStatic1 = 101 (сбросится, тк цикл кончится), nLocal1 = 101 (сбросится)
 */


/**
 * Задание 5. Перечисления - enum.
 *
 * Обратите внимание на явную и неявную инициализацию констант. 
 *
 * Выполняя задание по шагам, следите за значениями, которые принимает
 * переменная myColors.
 */

enum eColors
{
BLACK, //неявная 0
BLUE, //неявная 1
GREEN,//неявная 2
RED=5, //явная 5
YELLOW,//неявная 6
WHITE=RED+4 //явная 9
};

eColors myColors; //объявление переменной типа eColors = BLACK
myColors = BLACK; //BLACK
myColors = BLUE; //BLUE 
myColors = GREEN; //GREEN
myColors = RED; //RED
myColors = YELLOW; //YELLOW
myColors = WHITE; //WHITE

int nnn = BLACK; //любой целочисленной переменной можно присвоить
    //значение из списка инициализирующих значений
    //nnn = 0

//Именованные константы можно использовать в выражениях:
nnn = BLUE | YELLOW; //7 

/**
 * Раскомментируйте следующую строку и обратите внимание на ошибку при
 * компиляции.
 *
 * Модифицируйте выражение таким образом, чтобы компилятор не выдывал
 * ошибки.
 */

myColors = (eColors) 1; 

/**
 * Выполните следующее присваивание НЕ меняя перечисление и тип переменной
 * myColors.
 */

myColors = (eColors) 123;


/**
 * Задание 6.1 Логический тип bool.
 *
 * Выполняя задание по шагам, следите за значениями переменной b и
 * интерпретируйте результат. 
 *
 * Напишите эти значения в комментариях.
 */

int nNumber = 1;
bool b = (nNumber != 0); // true
b = (nNumber == 0); // false
b = (nNumber > 0); // true
b = (nNumber > 1); //false
b = 5; //true

/**
 * Вы всегда можете преобразовать логическое значение к целому явно или
 * компилятор может это сделать самостоятельно (неявно).
 *
 * Обратите внимание: как интерпретирует значения логических переменных
 * компилятор?
 */

int tmp =  b + 1; // true=1, false=0, 1+1=2

/**
 * Задание 6.2.
 *
 * В Григорианском календаре (которым мы все пользуемся) високосный год
 * определяется по следующему алгоритму: високосным является каждый
 * четвертый год, но каждый сотый високосным не является, при этом каждый
 * 400-й год все таки високосный. Т.е. 1823 - не високосный, 1824 -
 * високосный, 1900 - не високосный, 2000 - високосный.
 *
 * Напишите фрагмент кода, такой что логическая переменная isLeapYear
 * принимает значение true, если год, заданный переменной year -
 * високосный. Проверьте значение в отладчике.
 *
 * Указание: в этом задании нельзя использовать операторы if-else, switch и
 * тернарный оператор; необходимо написать логическое выражение в одну
 * строку.
 */

{
int year = 1823;
year = 1824;
year = 1900;
year = 2000;

bool isLeapYear = (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);
}

/**
 * Задание 7. Модификатор const и переменные.
 *
 * Раскомментируйте следующие две строчки и объясните (в комментариях)
 * ошибки при компиляции.
 */

{
//  const int nN; //
//  nN = 1; //
}

/**
 * Задание 8. Потоки ввода и вывода C++.
 *
 * Напишите фрагмент кода, который бы с помощью объектов потока std::cin и
 * std::cout делал бы следующее:
 *
 * 1. Выводил бы на экран номер задания.
 * 2. Считывал целое число.
 * 3. Считывал символ.
 * 4. Выводил пользователю введенный им символ.
 * 5. Выводил пользователю введенное им целое число.
 *
 * При этом добавьте в места, где от пользователя ожидается ввод,
 * соответствующие приглашения ко вводу (например, `Введите целое число: `). 
 */

{
int inputInt;
char inputChar;
}

/**
 * Задание 9. Логические условные операторы и операторы отношения.
 */

/**
 * Задание 9.1. 
 *
 * Напишите фрагмент кода, который переводит код символа, хранящийся в
 * переменной ch в противоположный регистр.
 *
 * Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
 * или нажал другую клавишу, которой символ не соответствует.
 *
 * Подсказка: работаем только с символами английского алфавита, для
 * которого в таблице кодов ASCII код каждой буквы нижнего регистра на 0x20
 * больше кода соответствующей буквы верхнего регистра.
 */

{
char ch;
/** Тут сформируйте значение переменной ch с помощью потока ввода. */

/** Тут измените регистр. */

/** Тут вывели получившийся символ пользователю. */
}

/**
 * Задание 9.2. 
 *
 * Напишите фрагмент кода, который реализует с помощью if (if/else)
 * следующую логику: если x меньше или равен 0, y=0, если x больше 0 но
 * меньше 1, то y=x, если x больше или равен 1, то y=1.
 *
 * Подумайте: какого типа должны или могут быть x и y?
 */

{
}

/**
 * Задание 9.3 
 *
 * Напишите фрагмент кода, который реализует с помощью switch следующую
 * логику: в переменной cInput типа char дано значение символа, введенного
 * любым способом.
 *
 * Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
 * переменной у значение переменной x.
 *
 * Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
 * переменной у значение (x * 2).
 *
 * Если любой другой симол, то вывести сообщение об ошибке.
 */

{
char ch;
}

/**
 * Задание 10. Циклы.
 */

/**
 * Задание 10.1.
 *
 * Напишите фрагмент кода, который реализует с помощью for следующую
 * логику: найти сумму заданного диапазона целых чисел.
 *
 * Введите границы с помощью потока ввода или с помощью средств отладки. 
 *
 * Предусмотрите защиту от ввода нижней границы больше, чем верхней.
 */

{
/** сформироыать границы диапазона */

/** проверить корректность значений */

/** вычислить сумму */

/** проверить в отладчике значение */
}

/**
 * Задание 10.2. 
 *
 * Напишите фрагмент кода, который реализует с помощью do-while следующую
 * логику: на каждой итерации цикла ввести с консоли целое значение и
 * покинуть цикл, если значение удовлетворяет условию: значение больше или
 * равно 10 и четное.
 */

{

}

/**
 * Задание 10.3. 
 *
 * Напишите фрагмент кода, который реализует с помощью while следующую логику: 
 *
 * 1. исходно int x = 0; 
 * 2. на каждой итерации x = x + 1, sum = sum + 1 / x;
 * 3. необходимо найти значение x, при котором sum > 1.7.
 */

{

}

/**
 * Задание 10.4.
 *
 * Раскомментируйте следующий блок кода, который считает сумму 10
 * последовательных натуральных чисел, начиная со 120. 
 *
 * Объясните логические ошибки в нем и исправьте их.
 */

{
// char start = 120, sum = 0;
// for (char n = start; n < start + 10; ++n) {
//    sum += n;
// }
}

return 0; /** код завершения приложения */
}
